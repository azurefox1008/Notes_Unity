# **一、作为行为组件的脚本** 

  &emsp;&emsp;**组件**（Component）：游戏对象（Game Object）中实现某些功能的集合，控制游戏对象的行为。Unity Editor 中使用 `Inspector` 更改组件属性。

  &emsp;&emsp;**脚本**：创建脚本实际上是在自定义新的组件类型，可以像其他组件一样将这种组件附加到游戏对象并在 `Inspector` 中编辑脚本中的值。大多数应用程序都需要脚本来响应玩家的输入并安排游戏过程中应发生的事件。除此之外，脚本可用于创建图形效果，控制对象的物理行为，甚至为游戏中的角色实现自定义的 AI 系统。
  
  &emsp;&emsp;**IDE**：Integrated Development Environment（集成开发环境），是一种提供工具和配套功能来方便开发其他软件的计算机软件，一般包括代码编译器、编译器、调试器和图形用户界面等工具。

  &emsp;&emsp; *Q：.NET？DLL？

  ## 创建脚本：
  
  &emsp;&emsp;方法1：项目面板 `Create` --> `C#Script`；


  &emsp;&emsp;方法2：组件菜单底部的 `Add Component` --> 下拉菜单底部的`New script`（只需一步即可创建并添加脚本）。
  
  ## 添加脚本（关联到对象）：
  
  &emsp;&emsp;方法1：拖拽； 

  &emsp;&emsp;方法2：点击 `Add Component` --> 从当前项目的脚本列表中选择；

  &emsp;&emsp;方法3：`Hierarchy`（层级视图）中选中对象 --> 顶栏 `Components` --> `Scripts` --> 从当前项目的脚本列表中选择。

  ## 编辑脚本：

  &emsp;&emsp;双击 Unity 中的脚本资源时，将在文本编辑器中打开此脚本。Unity默认的编译器是Visual Studio，可从 Unity 的偏好设置（选择 `Unity` --> `Preferences`）中的 `External Tools` 面板选择所需的任何编辑器。

  &emsp;&emsp;该文件的初始内容将如下所示：
  ```C#
  using UnityEngine;
  using System.Collections;

  public class 文件名 : MonoBehaviour {
    void Start () {  
        //使用此函数进行初始化
    }
    void Update () {  
        //每帧调用一次Update
    }
}
  ```
  &emsp;&emsp;为了连接 Unity 的内部架构，脚本将实现一个类，此类从 MonoBehaviour 的内置类派生而来。<u>*类的名称取自创建文件时提供的名称。**类名和文件名必须相同**才能使脚本组件附加到游戏对象*</u>。

  &emsp;&emsp;因此，最好在创建脚本时输入新脚本的名称而不是稍后编辑名称，如之后再编辑脚本名，脚本中类的名字并不会随着脚本名的编辑而更新，容易出错。

  &emsp;&emsp;注意：<u>*给脚本起名时不要使用数字，否则会有编译错误*</u>。
  
  ## 相关英语： 
  >component 组件 
  >
  >script 脚本
  >
  >IDE（Integrated Development Environment）集成开发环境
  >
  >hierarchy /haɪərɑːʳki/ （~~不知道能不能在这里插单词发音~~）a system or structure, different ranks or levels 层级视图
  >
  >fix compile errors 修复编译错误
  ****

  # **二、变量和函数** 

  ```C#
  using UnityEngine;
  using System.Collections;

  public class MainPlayer : MonoBehaviour 
  {
      public string myName;

      void Start () 
      {
          Debug.Log("I am alive and my name is " + myName);
      }
  }
  ```
  &emsp;&emsp;Debug.Log是一个能*将消息输出到Unity的控制台*的简单命令（Q：感觉很像printf()？）点击 ▶，会在 Unity Editor 主窗口底部以及 Console 窗口（`Window`> `Console`）中看到此消息。

  &emsp;&emsp;上面的代码在 `Inspector` 中创建一个标记为“My Name”的可编辑字段。

  &emsp;&emsp;![](EditingVarInspector.png)

  &emsp;&emsp;Unity 通过在变量名称中出现大写字母的位置引入空格来创建 Inspector 标签。但这纯粹是出于显示目的，在代码中应始终使用变量名称。

  &emsp;&emsp;在 C# 中，<u>*必须将变量声明为 **public** 才能在* `Inspector` *中查看该变量</u>*。

  &emsp;&emsp;Unity允许在游戏运行时更改脚本变量的值，无需停止和重新启动即可直接查看更改的效果。<u>*游戏运行过程结束时，变量的值将重置为点击 ▶ 之前的任何值*</u>。这样既可确保自由调整对象的设置，又不必担心会造成任何永久性损坏。

  ## 相关英语： 
  >variable 变量
  >
  >function 函数
  >
  >declaration 声明
  >
  >integer：a whole number 整数
  >
  >initialization /inˌitialiˈsation/ n.初始化
  >
  >initialize / initialise v.
  >
  >assign 赋值 —— reassign 重新赋值
  ***
  # **三、 约定和语法**
  ## 句点运算符（.）：
  &emsp;&emsp;作用类似于编写一串地址（C语言教材说是<u>取结构体成员</u> ）。使用（.）时可利用IntelliSense（代码智能提示）自动弹出的选项列表补完代码，这样做有助于提高编程速度并避免出错，也可以了解有哪些选项可用。
  ```C#
  void Start()
  {
      Debug.Log(transform.position.x);
      //transform包含position、rotation、scale

      if(transform.position.x <= 5f)
      //Q：5f？ A：f，浮点数float型
      {
          Debug.Log("I'm about to hit the ground!");
      }
  }
  ```
  ## 分号（;）：
  
  &emsp;&emsp;作用为<u>终止语句</u>。并非所有的代码都是语句，例如类声明语句、函数或if语句的首尾（opening/closing）等。

  ## 缩进：
  &emsp;&emsp;从技术角度来讲缩进并非必需，但能显示代码的功能结构，使代码清晰易读(<u>Shift + Tab 取消缩进</u>，<u>使用缩进时善用Tab键</u>，不要一个一个打空格了TAT)。

  ## 注释：
  &emsp;&emsp;除了可以留备注，~~否则一段时间后很可能只有上帝知道你写的是什么鬼代码_(:з」∠)_~~，还可以用于<u>暂时禁用部分代码</u>（很好用）。
  ## 相关英语：
  >convention 约定
  >
  >syntax 语法
  >
  >dot operator 句点运算符 —— a full stop 句点 —— period 句号
  >
  >IntelliSense 代码智能提示
  >
  >rotation 旋转
  >
  >indent 缩进
  ***
  # **四、IF语句**
  &emsp;&emsp;（emmmm这节内容相较于C没有新知识）
  ## 相关英语：
  > statement 语句

  > to make a decision based on a <u>condition</u> 根据<u>条件</u>作出决策
  ***
  # **五、循环**
  ## for循环：
  &emsp;&emsp;利用可控数量的迭代创建循环。

  ```C#
  for(int i = 0; i < numEnemies; i++)
  ```
  &emsp;&emsp;i为<u>迭代子</u>（iterator），作用是计算循环的迭代次数。1为循环的<u>步长</u>。

  ## **foreach循环：**

  &emsp;&emsp;foreach循环是for循环的简化版，也叫<u>只读</u>循环，用于<u>遍历数组和集合</u>（适用于<u>循环次数未知</u>或<u>计算循环次数较为复杂</u>的情况），在循环体中不能对集合或数组进行更改。能够应用foreach循环的编程语言类别：C#、Java、PHP、D语言。

  &emsp;&emsp;一般语法格式：

  &emsp;&emsp;foreach(数据类型 变量名 in 数组或集合)
  
  &emsp;&emsp;{
      循环体;
  }

  ```C#
 void Start () 
    {
        string[] strings = new string[3];
        //定义了一个包含3个字符串的数组
        
        strings[0] = "First string";
        strings[1] = "Second string";
        strings[2] = "Third string";
        //字符串赋值
        
        foreach(string item in strings)
        //数据类型string 字符串数组strings
        {
            print (item);
        }
    }
  ```

  ## 相关英语：
  >loop 循环 / ForLoop / WhileLoop / DoWhileLoop
  >
  >iterate：to say or do again; repeat 迭代
  >
  >iterator 迭代子
  >
  >...have a integer called xxx, which is set to three 有一个名为xxx值为3的整数
  >
  >in the console 在控制台中 
  >
  >run the commands in the body of the loop 不再运行循环主体中的命令
  >
  >&emsp;&emsp;Any operation that you need to carry out a defined number of times can be placed within a ForLoop.任何需要执行指定次数的运算都可以用for循环来实现。
***
# **六、作用域和访问修饰符**
## **变量作用域：**
&emsp;&emsp;代码中可以使用该变量的区域。代码块（code blocks）通常用于定义变量作用域，用花括号来表示。

## **公开和私有访问修饰符：**

&emsp;&emsp;**类**（Class）是<u>面向对象</u>程序设计（OOP，Object-Oriented Programming）实现信息封装的基础。类的实质是一种引用数据类型，类似于 byte、short、int（char）、long、float、double 等基本数据类型，不同的是它是一种复杂的数据类型。

> **Q : 面向对象编程？**
>
>A ：<font color='teal'>面向过程</font>（Procedure Oriented 简称PO ：如C语言）
解决一个问题时，面向过程会把事情拆分成： 一个个函数和数据（用于方法的参数），之后按照一定的顺序，执行完这些方法（每个方法看作一个过程），方法执行完毕，问题解决。
>
>&emsp;&emsp;<font color='orange'>面向对象</font>（Object Oriented简称OO ：如C++，JAVA等语言）：
解决一个问题的时候，面向对象会把问题里的事物抽象成对象的概念，之后给对象赋一些属性和方法，然后让每个对象去执行自己的方法，问题解决。
>
>&emsp;&emsp;**例1：洗衣机里面放有脏衣服，怎么洗干净？**
>
>&emsp;&emsp;<font color='teal'>面向过程</font>：
>
>&emsp;&emsp;1、执行加洗衣粉方法；
>
>&emsp;&emsp;2、执行加水方法；
>
>&emsp;&emsp;3、执行洗衣服方法；
>
>&emsp;&emsp;4、执行清洗方法；
>
>&emsp;&emsp;5、 执行烘干方法；
>
>&emsp;&emsp;<u>将解决这个问题的过程拆成一个个方法（不调用对象），通过一个个方法的执行来解决问题</u>。
>
>&emsp;&emsp;<font color='orange'>面向对象</font>：
>
>&emsp;&emsp;1、先弄出两个对象：对象①“洗衣机” 和 对象②“人”；
>
>&emsp;&emsp;2、针对“洗衣机”加入一些属性和方法：“洗衣服方法”“清洗方法”、“烘干方法”；
>
>&emsp;&emsp;3、针对“人”加入属性和方法：“加洗衣粉方法”、“加水方法”；
>
>&emsp;&emsp;4、然后执行
>
>&emsp;&emsp;&emsp;人 . 加洗衣粉&emsp;<font color='limegreen'>*//这里用了句点运算符*</font>
>
>&emsp;&emsp;&emsp;人 . 加水
>
>&emsp;&emsp;&emsp;洗衣机 . 洗衣服
>
>&emsp;&emsp;&emsp;洗衣机 . 清洗
>
>&emsp;&emsp;&emsp;洗衣机 . 烘干
>
>&emsp;&emsp;<u>即先抽象出对象，然后用对象执行方法的方式解决问题</u>。
>
>&emsp;&emsp;**例2： 打麻将 / 你 我 他**
>
>&emsp;&emsp;<font color='teal'>面向过程</font>： 打麻将 （你，我，他）&emsp;<font color='limegreen'>*//这里大概是参数表*</font>
>
>&emsp;&emsp;<u>拆成一个动作，把数据丢进去</u>。
>
>&emsp;&emsp;<font color='orange'>面向对象</font>： 我.打麻将（你，他） or 你.打麻将（我，他） or 他.打麻将 (我，你)
>
>&emsp;&emsp;<u>抽象出对象，对象执行动作</u>。
>
> &emsp;&emsp;**例3：五子棋**
>
>&emsp;&emsp;<font color='teal'>面向过程</font>首先分析问题的步骤：
>
>&emsp;&emsp;开始游戏-->黑子先走-->绘制画面-->判断输赢-->轮到白子-->绘制画面-->判>断输赢-->返回步骤2-->输出最后结果。把每个步骤用不同的方法来实现。
>
>&emsp;&emsp;<font color='orange'>面向对象</font>则是从另外的思路来解决问题：
>
>&emsp;&emsp;整个五子棋可以分为：①黑白双方，这两方的行为是一模一样的；②棋盘系统，负责绘制画面； ③规则系统，负责判定诸如犯规、输赢等。
>
>&emsp;&emsp;第一类对象（玩家对象）负责接受用户输入，并告知第二类对象（棋盘对象）棋子布局的变化，棋盘对象接收到了棋子的变化就要负责在屏幕上面显示出这种变化，同时利用第三类对象（规则系统）来对棋局进行判定。
>
>&emsp;&emsp;面向对象是<u>以功能来划分问题</u>，而不是步骤。同样是绘制棋局，这样的行为在面向过程的设计中分散在了多个步骤中，很可能出现不同的绘制版本，因为通常设计人员会考虑到实际情况进行各种各样的简化。而面向对象的设计中，绘图只可能在棋盘对象中出现，从而保证了绘图的统一。

&emsp;&emsp;类内定义的变量不同于函数内声明的变量，前者分配有<u>访问修饰符</u>。访问修饰符是<u>声明变量时放在数据类型前的关键词</u>（key word），用途是<u>定义能够看到变量或函数的位置</u>。如果其他脚本需要访问某个变量或函数就应将其公开（public），反之设为私有（private）。

> Q：函数内声明的变量不需要添加访问修饰符？intenal？protected？程序集？dll？

&emsp;&emsp;把变量设为公开意味着<u>可以从类的外部（如通过其他脚本）访问这个变量</u>，也意味着<u>该变量能在`Inspector`的组件上显示和编辑</u>，将某些最好能在测试时修改的变量设为公开，就可以直接在组件上进行修改而不需要暂停、打开脚本进行修改、再次运行。

&emsp;&emsp;注意：如果变量在类中初始化为默认值，它仍会被`Inspector`中写入的值所覆盖。但如果变量的值在函数中被赋值，由于函数会在`Inspector`中设置过变量之后被执行，因此不能被`Inspector`中写入的值所覆盖，相反，函数中的值会覆盖`Inspector`中写入的值。

私有变量只能在类内编辑，<u>C#中未指定访问修饰符的任意变量**默认使用私有访问修饰符**</u>。最好将变量全部设为私有，除非需要它们公开以满足特定需要。
## 相关英语：
> scope 作用域
>
> access modifiers 访问修饰符
>
>be overridden by（变量的值被...）覆盖
>
> class 类 / <u>local</u> to this class 该类的<u>局部</u>代码
>
> reset 重置
***
# **七、Awake and Start**
Awake和Start是加载脚本时自动调用的两个函数。
```C#
using UnityEngine;
using System.Collections;

public class AwakeAndStart : MonoBehaviour
{
    void Awake ()
    {
        Debug.Log("Awake called.");
    }
    
    void Start ()
    {
        Debug.Log("Start called.");
    }
}
```
**Awake**<u>在未启用脚本组件时也可以被调用</u>，因此Awake非常适用于在脚本与初始化之间的任何引用。

**Start函数**：当该脚本绑定的对象<u>*进入场景*</u>时会被调用，<u>*必须启用脚本组件才能被调用*</u>，Start在<u>Awake之后、第一次调用Update函数之前</u>调用，因此，Start函数是进行所有初始化的理想位置。

<u>Start和Awake in the lifetime of a script attached to an object只能被调用一次，因此不能通过禁用和重新启用脚本来重复执行Start函数。</u>


## 相关英语：
>load script 加载脚本
>
>enable script component 启用脚本组件
>
>be <u>called</u> once （一个函数）被<u>调用</u>一次 
>
>disable 禁用 —— re-enable 重复执行 
***
